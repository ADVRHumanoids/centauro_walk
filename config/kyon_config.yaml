solver:
  type: ilqr
  ipopt.linear_solver: ma57
  ipopt.tol: 0.1
  ipopt.constr_viol_tol: 0.01
  ipopt.print_level: 5
  ipopt.suppress_all_output: 'yes'
  ipopt.sb: 'yes'
#  ipopt.hessian_approximation: exact
#  ilqr.merit_der_threshold: 1e-3
#  ilqr.defect_norm_threshold: 1e-3
  ilqr.constraint_violation_threshold: 1e-2
  ilqr.suppress_all_output: 'yes'
  ilqr.codegen_enabled: true
  ilqr.codegen_workdir: /tmp/tyhio
  ilqr.enable_gn: true
  ilqr.hxx_reg_base: 0.0
  ilqr.n_threads: 0
  print_time: 0


costs:
  - base_z
  - joint_posture
  - joint_regularization

.define:
    - &w_com 70.
    - &w_postural 5.
    - &w_a 6e-2
    - &w_f 1e-3

base_z:
  type: Cartesian
  distal_link: base_link
  indices: [2]
  nodes: all
  weight: *w_com

joint_posture:
  type: Postural
  weight: *w_postural
  nodes: all


# todo: wrong, as the order COUNTS. If I add the contacts after the joint regularization, they wont get considered.
joint_regularization:
  type: Regularization
  nodes: all
  weight:
#    velocity: *w_v
    acceleration: *w_a # 0.01
    force: *w_f # todo <----- how to do? if there are more forces...

