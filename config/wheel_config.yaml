solver:
  type: ilqr
  ipopt.linear_solver: ma57
  ipopt.tol: 0.1
  ilqr.tol: 0.01
  ipopt.constr_viol_tol: 0.01
  ilqr.constr_viol_tol: 0.01
#  ipopt.hessian_approximation: exact
  ipopt.print_level: 5
  ipopt.suppress_all_output: 'yes'
  ipopt.sb: 'yes'
  ilqr.suppress_all_output: 'yes'
  ilqr.codegen_enabled: true
  ilqr.codegen_workdir: /tmp/tyhio
  ilqr.enable_gn: true
  ilqr.hxx_reg_base: 0.0
  ilqr.n_threads: 0
  print_time: 0

constraints:
  - contact_1
  - contact_2
  - contact_3
  - contact_4

costs:
  - final_base_xy
  - com_height
  - velocity_regularization
  - acceleration_regularization
  - force_regularization
  - joint_posture
  - joint_posture_ankles
  - joint_posture_wheels
  - joint_posture_ub
  - base_orientation
  - z_contact_1
  - z_contact_2
  - z_contact_3
  - z_contact_4
#  - wheel_inclination_1
#  - wheel_inclination_2
#  - wheel_inclination_3
#  - wheel_inclination_4

.define:
    - &w_com 1.
    - &w_base_ori 1.
    - &w_base_xy 1.
    - &w_ball_xy 10.
    - &w_ball_z 50.
    - &w_ball_ori 20.
    - &w_postural_roll 1.
    - &w_postural 0.05
    - &w_postural_ub 0.5
    - &w_postural_ankles 10.
    - &w_postural_wheels 10.
    - &wheel_radius 0.078

final_base_xy:
  type: Cartesian
  distal_link: base_link
  indices: [0, 1]
#  nodes: ${range(5, N)}
  nodes: all
  cartesian_type: velocity
  weight: *w_base_xy

com_height:
  type: Cartesian
  distal_link: base_link
  indices: [2]
  nodes: all
  weight: *w_com

base_orientation:
  type: Cartesian
  distal_link: base_link
  indices: [3, 4, 5]
#  nodes: ${range(N-8, N)}
  nodes: all
  cartesian_type: velocity
  weight: *w_base_ori

# ===============================

rolling_contact_1:
  type: Rolling
  frame: wheel_1
  radius: *wheel_radius

rolling_contact_2:
  type: Rolling
  frame: wheel_2
  radius: *wheel_radius

rolling_contact_3:
  type: Rolling
  frame: wheel_3
  radius: *wheel_radius

rolling_contact_4:
  type: Rolling
  frame: wheel_4
  radius: *wheel_radius

# ==================================

cartesian_contact_1:
  type: Cartesian
  distal_link: contact_1

cartesian_contact_2:
  type: Cartesian
  distal_link: contact_2

cartesian_contact_3:
  type: Cartesian
  distal_link: contact_3

cartesian_contact_4:
  type: Cartesian
  distal_link: contact_4

# ==================================

interaction_wheel_1:
  type: VertexForce
  frame: contact_1
  fn_min: 10.0
  enable_fc: false
  friction_coeff: 0.5
  vertex_frames:
    - wheel_1

interaction_wheel_2:
  type: VertexForce
  frame: contact_2
  fn_min: 10.0
  enable_fc: false
  friction_coeff: 0.5
  vertex_frames:
    - wheel_2

interaction_wheel_3:
  type: VertexForce
  frame: contact_3
  fn_min: 10.0
  enable_fc: false
  friction_coeff: 0.5
  vertex_frames:
    - wheel_3

interaction_wheel_4:
  type: VertexForce
  frame: contact_4
  fn_min: 10.0
  enable_fc: false
  friction_coeff: 0.5
  vertex_frames:
    - wheel_4

contact_1:
  type: Contact
  subtask: [interaction_wheel_1, rolling_contact_1]

contact_2:
  type: Contact
  subtask: [interaction_wheel_2, rolling_contact_2]

contact_3:
  type: Contact
  subtask: [interaction_wheel_3, rolling_contact_3]

contact_4:
  type: Contact
  subtask: [interaction_wheel_4, rolling_contact_4]

joint_posture_ankles:
  type: Postural
  weight: *w_postural_ankles
  indices: [4, 10, 16, 22]
  nodes: all

joint_posture_wheels:
  type: Postural
  weight: *w_postural_wheels
  indices: [5, 11, 17, 23]
  nodes: all


joint_posture:
  type: Postural
  weight: *w_postural
  indices: [0, 1, 2, 3, #4, 5, no postural on ankle yaw, no wheel
            6, 7, 8, 9, #10, 11,
            12, 13, 14, 15, #16, 17
            18, 19, 20, 21, #22, 23
            ]
  nodes: all

joint_posture_ub:
  type: Postural
  weight: *w_postural_ub
  indices: [24, # torso
            25, 26, 27, 28, 29, 30, # arm1
            31, 32, 33, 34, 35, 36, # arm2
            37, 38 # head, velodyne
            ]
  nodes: all

# todo: wrong, as the order COUNTS. If I add the contacts after the joint regularization, they wont get considered.
velocity_regularization:
  type: Regularization
  nodes: all
#  indices: [0, 1, 2, 3, 4, 5,
#            6, 7, 8,
#            10, 11, 12,
#            14, 15, 16,
#            18, 19, 20,
#            22, 23, 24, 25, 26,
#            27, 28, 29, 30, 31]
  weight:
    velocity: 0.01

acceleration_regularization:
  type: Regularization
  nodes: all
  weight:
    acceleration: 1e-1 # 0.01

force_regularization:
  type: Regularization
  nodes: all
  weight:
    force: 1e-3 # todo <----- how to do? if there are more forces...

z_contact_1:
  type: Cartesian
  distal_link: contact_1
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z

z_contact_2:
  type: Cartesian
  distal_link: contact_2
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z

z_contact_3:
  type: Cartesian
  distal_link: contact_3
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z

z_contact_4:
  type: Cartesian
  distal_link: contact_4
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z