solver:
  type: ipopt
  ipopt.linear_solver: ma57
  ipopt.tol: 0.1
  ipopt.max_iter: 200
#  ilqr.tol: 0.01
  ipopt.constr_viol_tol: 0.01
#  ilqr.constr_viol_tol: 0.01
#  ipopt.hessian_approximation: exact
#  ipopt.print_level: 5
#  ipopt.suppress_all_output: 'no'
#  ipopt.sb: 'no'
#  ilqr.suppress_all_output: 'yes'
#  ilqr.codegen_enabled: true
#  ilqr.codegen_workdir: /tmp/tyhio
#  ilqr.enable_gn: true
#  ilqr.hxx_reg_base: 0.0
#  ilqr.n_threads: 0
#  print_time: 1

constraints:
  - ball_1_contact
  - ball_2_contact
  - ball_3_contact
  - ball_4_contact
  - z_ball_1
  - z_ball_2
  - z_ball_3
  - z_ball_4
  - final_base_xy
  - base_orientation

costs:
#  - com_height
  - joint_regularization
  - joint_posture

.define:
    - &w_com 0.5
    - &w_base_ori 20.
    - &w_base_xy 10.
    - &w_ball_xy 10.
    - &w_ball_z 1.
    - &w_ball_ori 20.
    - &w_postural_roll 1.
    - &w_postural 0.1
    - &wheel_radius 0.124

final_base_xy:
  type: Cartesian
  distal_link: base_link
  indices: [0, 1]
  nodes: ${[N]}
#  nodes: all
#  weight: *w_base_xy

com_height:
  type: Cartesian
  distal_link: base_link
  indices: [2]
  nodes: all
  weight: *w_com

base_orientation:
  type: Cartesian
  distal_link: base_link
  indices: [3, 4, 5]
  nodes: ${[N]}
#  weight: *w_base_ori

# ===============================

rolling_contact_1:
  type: Rolling
  frame: wheel_1
  radius: *wheel_radius

rolling_contact_2:
  type: Rolling
  frame: wheel_2
  radius: *wheel_radius

rolling_contact_3:
  type: Rolling
  frame: wheel_3
  radius: *wheel_radius

rolling_contact_4:
  type: Rolling
  frame: wheel_4
  radius: *wheel_radius

# ==================================

interaction_wheel_1:
  type: VertexForce
  frame: ball_1
  fn_min: 10.0
#  enable_fc: true
#  friction_coeff: 0.5
  vertex_frames:
    - wheel_1

interaction_wheel_2:
  type: VertexForce
  frame: ball_2
  fn_min: 10.0
#  enable_fc: true
#  friction_coeff: 0.5
  vertex_frames:
    - wheel_2

interaction_wheel_3:
  type: VertexForce
  frame: ball_3
  fn_min: 10.0
#  enable_fc: true
#  friction_coeff: 0.5
  vertex_frames:
    - wheel_3

interaction_wheel_4:
  type: VertexForce
  frame: ball_4
  fn_min: 10.0
#  enable_fc: true
#  friction_coeff: 0.5
  vertex_frames:
    - wheel_4

ball_1_contact:
  type: Contact
  subtask: [interaction_wheel_1, rolling_contact_1]

ball_2_contact:
  type: Contact
  subtask: [interaction_wheel_2, rolling_contact_2]

ball_3_contact:
  type: Contact
  subtask: [interaction_wheel_3, rolling_contact_3]

ball_4_contact:
  type: Contact
  subtask: [interaction_wheel_4, rolling_contact_4]


joint_posture:
  type: Postural
  weight: *w_postural
  indices: [0, 1, 2,
            4, 5, 6,
            8, 9, 10,
            12, 13, 14]
  nodes: all

# todo: wrong, as the order COUNTS. If I add the contacts after the joint regularization, they wont get considered.
joint_regularization:
  type: Regularization
  nodes: all
  weight:
#    velocity: 1e-1
    acceleration: 1e-3 # 0.01
    force: 1e-4 # todo <----- how to do? if there are more forces...

z_ball_1:
  type: Cartesian
  distal_link: ball_1
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z

z_ball_2:
  type: Cartesian
  distal_link: ball_2
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z

z_ball_3:
  type: Cartesian
  distal_link: ball_3
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z

z_ball_4:
  type: Cartesian
  distal_link: ball_4
  indices: [2]
  cartesian_type: position
  weight: *w_ball_z