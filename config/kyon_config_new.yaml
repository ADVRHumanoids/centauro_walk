solver:
  type: ilqr
  ipopt.linear_solver: ma57
  ipopt.tol: 0.1
#  ilqr.merit_der_threshold: 1e-3
#  ilqr.defect_norm_threshold: 1e-3
  ipopt.constr_viol_tol: 0.01
  ilqr.constraint_violation_threshold: 1e-2
#  ipopt.hessian_approximation: exact
  ipopt.print_level: 5
  ipopt.suppress_all_output: 'yes'
  ipopt.sb: 'yes'
  ilqr.suppress_all_output: 'yes'
  ilqr.codegen_enabled: true
  ilqr.codegen_workdir: /tmp/tyhio
  ilqr.enable_gn: true
  ilqr.hxx_reg_base: 0.0
  ilqr.n_threads: 0
  print_time: 0

#constraints:


costs:
  - xy_contact_1
  - xy_contact_2
  - xy_contact_3
  - xy_contact_4
  - z_contact_1
  - z_contact_2
  - z_contact_3
  - z_contact_4
  - base_xy
  - base_orientation
  - base_z
  - velocity_regularization
  - acceleration_regularization
  - joint_posture
  - contact_1_contact
  - contact_2_contact
  - contact_3_contact
  - contact_4_contact
  - contact_1_regularization
  - contact_2_regularization
  - contact_3_regularization
  - contact_4_regularization
#  - joint_posture_ub

.define:
    - &w_com 50.
    - &w_base_ori 50.
    - &w_base_xy 50.
    - &w_contact_z 500.
    - &w_contact_xy 0.
    - &w_postural 5.
    - &w_postural_ub 10.
    - &w_v 1
    - &w_a 6e-2
    - &w_f 1e-3
    - &w_contact 500
    - &w_contact_ori 20.
    - &w_postural_roll 1.

base_xy:
  type: Cartesian
  distal_link: base_link
  indices: [0, 1]
  nodes: ${N}
#  nodes: all
#  cartesian_type: velocity
  weight: *w_base_xy

base_z:
  type: Cartesian
  distal_link: base_link
  indices: [2]
  nodes: all
  weight: *w_com

base_orientation:
  type: Cartesian
  distal_link: base_link
  indices: [3, 4, 5]
  nodes: ${N}
#  nodes: all
#  cartesian_type: velocity
  weight: *w_base_ori

# ===============================

zero_velocity_contact_1:
  type: Cartesian
  distal_link: contact_1
  indices: [0, 1, 2]
  cartesian_type: velocity

zero_velocity_contact_2:
  type: Cartesian
  distal_link: contact_2
  indices: [0, 1, 2]
  cartesian_type: velocity

zero_velocity_contact_3:
  type: Cartesian
  distal_link: contact_3
  indices: [0, 1, 2]
  cartesian_type: velocity

zero_velocity_contact_4:
  type: Cartesian
  distal_link: contact_4
  indices: [0, 1, 2]
  cartesian_type: velocity

# ==================================

interaction_contact_1:
  type: VertexForce
  frame: contact_1
  fn_min: 10.0
  enable_fc: true
  friction_coeff: 0.5
  weight: *w_contact
  vertex_frames:
    - contact_1

interaction_contact_2:
  type: VertexForce
  frame: contact_2
  fn_min: 10.0
  enable_fc: true
  friction_coeff: 0.5
  vertex_frames:
    - contact_2

interaction_contact_3:
  type: VertexForce
  frame: contact_3
  fn_min: 10.0
  enable_fc: true
  friction_coeff: 0.5
  vertex_frames:
    - contact_3

interaction_contact_4:
  type: VertexForce
  frame: contact_4
  fn_min: 10.0
  enable_fc: true
  friction_coeff: 0.5
  vertex_frames:
    - contact_4

contact_1_contact:
  type: Contact
  subtask: [interaction_contact_1, zero_velocity_contact_1]

contact_2_contact:
  type: Contact
  subtask: [interaction_contact_2, zero_velocity_contact_2]

contact_3_contact:
  type: Contact
  subtask: [interaction_contact_3, zero_velocity_contact_3]

contact_4_contact:
  type: Contact
  subtask: [interaction_contact_4, zero_velocity_contact_4]

joint_posture:
  type: Postural
  weight: *w_postural
  indices: [0, 1, 2,
            3, 4, 5,
            6, 7, 8,
            9, 10, 11]
  nodes: all

joint_posture_ub:
  type: Postural
  weight: *w_postural_ub
  indices:  [12, 13, 14, 15, 16,
             17, 18, 19, 20, 21]
  nodes: all
# todo: wrong, as the order COUNTS. If I add the contacts after the joint regularization, they wont get considered.
velocity_regularization:
  type: Regularization
  variable_name: v
  nodes: all
  weight: *w_v

acceleration_regularization:
  type: Regularization
  variable_name: a
  nodes: all
  weight: *w_a

contact_1_regularization:
  type: Regularization
  variable_name: f_contact_1
  nodes: all
  weight: *w_f

contact_2_regularization:
  type: Regularization
  variable_name: f_contact_2
  nodes: all
  weight: *w_f

contact_3_regularization:
  type: Regularization
  variable_name: f_contact_3
  nodes: all
  weight: *w_f

contact_4_regularization:
  type: Regularization
  variable_name: f_contact_4
  nodes: all
  weight: *w_f

z_contact_1:
  type: Cartesian
  distal_link: contact_1
  indices: [2]
  cartesian_type: position
  weight: *w_contact_z

z_contact_2:
  type: Cartesian
  distal_link: contact_2
  indices: [2]
  cartesian_type: position
  weight: *w_contact_z

z_contact_3:
  type: Cartesian
  distal_link: contact_3
  indices: [2]
  cartesian_type: position
  weight: *w_contact_z

z_contact_4:
  type: Cartesian
  distal_link: contact_4
  indices: [2]
  cartesian_type: position
  weight: *w_contact_z

xy_contact_1:
  type: Cartesian
  distal_link: contact_1
  indices: [0, 1]
  cartesian_type: position
  weight: *w_contact_xy

xy_contact_2:
  type: Cartesian
  distal_link: contact_2
  indices: [0, 1]
  cartesian_type: position
  weight: *w_contact_xy

xy_contact_3:
  type: Cartesian
  distal_link: contact_3
  indices: [0, 1]
  cartesian_type: position
  weight: *w_contact_xy

xy_contact_4:
  type: Cartesian
  distal_link: contact_4
  indices: [0, 1]
  cartesian_type: position
  weight: *w_contact_xy

